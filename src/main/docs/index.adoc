= Static Analysis of Dynamic Languages
Jennifer Strater <s161600@student.dtu.dk>
{localdate}

:toc:
:icons: font
:quick-uri: http://jlstrater.github.io/groovy-compiler-project

ifdef::backend-html5[]
This report describes the work done as part of the Compiler Construction Course and the special topics course Static
Analysis of Dynamic Languages in the Spring Semester of 2017 by Jenn Strater. If you prefer, you can download this
document as a link:../pdf/index.pdf[pdf] instead.
endif::[]

== Introduction
The study of static analysis in the context of dynamic languages is an interesting and complex problem because it
presents different challenges than the ones found in traditional static languages.  For this study, I chose the
dynamic programming language Groovy because of my background with the language and knowledge of some of the inner
workings.  Additionally, the bytecode manipulation and analysis framework ASM<<1>> was used because of its
use within the current Groovy compiler.

Since dynamic languages, particularly Groovy, have custom logic to support their dynamic features, the implementation
 may vary from other compilers such as ones for Java. Investigating the differences in performance and implementation
 are the topic of this project.

The language is primarily developed by volunteer open source contributors and not a full time
dedicated support staff with resources to fix it. Therefore, some implementations of the language features are not as optimal as
they could be.  Particularly when we look at benchmarking comparisons of Groovy to standard core Java and the quality
of the output of the bytecode prouced by the Groovy compiler, one can see the differences.  It's also been very useful
and quite a unique experience to work with a compiler hands-on used in many production systems around the world
and to have direct access to the users and community.

=== The Three Compiler Options

For background, within the groovy project, there are three different ways to compile groovy code: the legacy compiler
also labeled `groovyc`, the indy option, and the static compilation flag.


The main differences between the three have to do with method
invocation.  Let's look at the differences in the context of the bytecode generated for a simple helloworld.groovy
program. The smallest `Hello, World!` example would be the simple script:
[source,groovy]
----
println 'Hello, World!'
----

==== Legacy Compiler
In the legacy compiler, implemnted in a pre 2.0 version of the language, methods are run using a callsite caching
mechanism<<2>> as seen in <<legacy-compilation>> which has much worse performance than other invocation strategies.
However, when using groovy with versions of Java less than Java7, this is the only option.

[[legacy-compilation]]
.Bytecode from Compilation with Groovyc
[source,assembly, linenums]
----
include::{sourcedir}/helloworld-groovyc.bytecode[lines=22..35]
----

==== Invoke Dynamic (Indy)
Invoke Dynamic, aka _Indy_, is a flag set during compilation to specify that the compiler should replace the outdated
callsite caching mechanism with the Java7 InvokeDynamic instruction.  It also requires a version of groovy that supports
 the _indy_ option such as the `groovy-all` or the `groovy-indy` jars<<3>>.  From a command line installation of
 groovy-all, that can be done as seen in <<compiling-with-indy>>.

[[compiling-with-indy]]
.Compiling With Invoke Dynamic
[source,shell]
----
groovyc --indy helloworld.groovy
----

The source code in <<indy-compilation>> below is the same helloworld source code as <<legacy-compilation>>, but with the indy
flag set.  Notice the difference in the two main methods.  The overhead of the legacy compiler, in particular for
maintaining the callsite information, is much higher than for using _indy_.

[[indy-compilation]]
.Bytecode from Compilation with Invoke Dynamic
[source,assembly, linenums]
----
include::{sourcedir}/helloworld-indy.bytecode[lines=17..25]
----

==== Static Compilation
Another option for compiling groovy code is static compilation which is set through the config script as shown in
<<sc-config>>.  Static Compilation adds some additional functionality such as type checking and limiting the scope of
Groovy's metaprogramming capabilities.

[[sc-config]]
.Static Compilation Configuration Script
[source, groovy]
----
withConfig(configuration) {
    ast(groovy.transform.CompileStatic)
}
----

In small examples, there are few differences between Indy and Static Compilation.  However, with larger more complex
programs, Static Compilation is often the way to go.  However, because it is also the strictest compilation option,
some programs may not compile if they use features of the Groovy language that violate static compilation such as the
def type notation.

[source,assembly, linenums]
----
include::{sourcedir}/helloworld-static.bytecode[lines=17..25]
----

=== Scripts vs Applications

The bytecode generated as seen in <<bytecode>> includes a lot more than a simple print statement.  In order for the code
 to run on the JVM, Groovy adds a wrapper around the code of type `groovy.lang.Script`. The script contains a `run`
 method with all of the code for the script. The main method runs the simple script.  There's also a MetaClass, that
 contains information about the Script.  This isn't used in the simple Hello World example, but is used for complex
 dynamic features of Groovy.  For programs with a main class, the scripting wrapper is not used.

[[bytecode]]
.Complete Bytecode Example for HelloWorld
[source,assembly, linenums]
----
include::{sourcedir}/helloworld-static.bytecode[]
----

The additional overhead from the metaclassing can have affects on the performance of the code.  To look at more
comparisons of the bytecode optimizations for scripts and applications/jars, see the
link:https://jlstrater.github.io/groovy-compiler-project/bytecode/index.html[bytecode report].

== Identification of Potential Optimizations
To begin any investigation into potential optimizations, it is important to first look at the cause and effect of
various parts of the system in this case, the groovy compiler itself.

== The Source of the Problem
Starting with the bytecode generated from each of the three compiler options, we found some common themes.  The main
source of the extra overhead in Groovy bytecode is from the build up and tear down of the stack.  This occurs from the
 implementation of the return by default feature of the Groovy programming language. In order to make it work, the
 compiler keeps track of the result of each statement as it's executed in case that is the value that needs to be
 returned.  However, if the method is void, and thus should run return anything, or has no possible route from the
 current statement to the end, then the operations to store the value on the stack are not needed and the beginning of
 the next statement compilation adds a pop to remove this superfluous value.  One example of this is shown below in
 <<method-pops>>.

[[[method-pops]]
.Groovy Compiler Implementation for Block Statements
 [source, java, linenums]
 ----
 include::https://github.com/apache/groovy/blob/master/src/main/org/codehaus/groovy/classgen/asm/StatementWriter.java[76..90]
 ----

== Solutions
=== Post Pass Optimization
In order to solve this problem in the short-term, we propose a post-pass optimization to identify sequences of
operations that are just doing busy work. The two first identified are load and pop as shown in <<load-pop-example>>.

In collectloop with static compilation in the run() method

[[load-pop-example]]
.Load then Pop Example
A superfluous load then pop in the generated bytecode from the collectloop.groovy script with static compilation.
[source, assembly]
----
include::{sourcedir}/collectloop-static.bytecode[lines=47..48]
----

and

[[dup-store-pop-example]]
.Dup Store Pop Example
An example from the nsieve.groovy script after indy compilation. This extract is from the countSieve() method.
[source, assembly]
----
include::{sourcedir}/nsieve-indy.bytecode[lines=152..154]
----

When a load is immediately followed by a pop like in the first example, both operations can be deleted.  When the
sequence is dupe, store, then pop like in the second example, the dupe and pop can be removed and the store should be
left.  There are of course, many other variations of these duplicated efforts throughout the examples.  For simplicity,
we just chose these two.  Adding more small tweaks would have diminishing returns.  Ultimately, the root cause of the
problem should be fixed in the compiler itself instead of in a post-pass optimization.

== Project
The source code in this project is published to http://github.com/jlstrater/groovy-compiler-project[Github]. It contains
  a simple Groovy application with tests and documentation as well as some example scripts, and jars.

=== Setup
The project is setup using the build tool Gradle with several plugins for making fat jar files, running a groovy
application, a static analysis tool for groovy, and generating documentation.  The project can be run using the gradle
wrapper included with the source code.

=== Implementation
For scripts, the application takes the script specified as an argument to the program and applies each of the three
compilation options using the command line execution API native to Java.  After the bytecode is generated using the
 default compiler, the generated bytecode is imported into the program using an ASM reader.  Using the ASM framework, the
bytecode is optimized to remove the extraneous instructions.  A separate pass is done to ensure the lines removed are
not the target of a jump operation.

=== Test Cases
To test the efficacy of the bytecode optimizations, a variet of different test cases were used.  There were a number of
scripts included in the resources directory that covered a wide variety of typical Groovy code operations including the
simple hello world example, looping, complex branching, and pattern matching.  To ensure no breaking changes, the
bytecode was run before and after the changes to ensure the correct output.

In addition to the small scripts, a number of large jar files including the groovy-all distribution and this application
were added to the test suite. For simplicity, the before and after source code for applications and jar files were not
included in the report -- only the number of lines removed.

=== Reports

=== Performance Differences

Since the optimization removes a lot of busy work operations, it was expected that the optimizations would result in a
performance difference.  However, probably due to the high overhead of the groovy library in comparison to the scripts
and applications run, we were unable to detect a statistically significant difference in the performance for any of the
test cases.

=== Jar Size Differences

After asking the Groovy compiler creators about the potential optimization on the community mailing list<<3>>, it was
revealed that the performance of the JVM is highly tuned and therefore the optimization I was proposing would not be
expected to have a major performance impact. However, one way it would have an impact is in the size of the output.  For
most cases, the size of the jar doesn't matter; however, in very large applications, the size of the bytecode may exceed
the limit of the JVM.  In that case, we could show that this optimization would have an advantage.  However, I do not
have any examples that large to test.

=== Challenges
As mentioned in the section on jar size differences, one of the major challenges of this project was coming up with
large examples that would be testable.  Many large groovy applications have many dependencies that are actually Java and
not Groovy or are packaged in a way that I could not use the traditional Java command line jar option to put it back
together again after running the optimization.


== Next Steps

In the immediate future, I would like to submit my final post-pass optimzition as a pull request to the current Groovy
compiler.  This would require integrating the current reader and writer into the existing ASM framework.

=== Fix the Compiler

The long term goal of this project would be to fix the underlying problems with the compiler when it's generating these
unnecessary instructions.  The potential spots for optimization would be in the handling of the return statement.
First, if we know that the method is void, then the compiler does not need to keep track of anything on the stack.
Next, if the method is not void then I would start by doing a backward analysis of the code to find the potential exits.
After identifying the exits, only those statements need to be tracked on the stack and the rest of the statements can be
  eliminated.

== Bibliography
[bibliography]
- [[[1]]] ASM. 'ASM - Home Page'. 23 Dec 2016. http://asm.ow2.org
- [[[2]]] Cedric Champeau. 'Using Groovy to play with invokedynamic'. 31 Jan 2013.
http://melix.github.io/blog/2013/01/31/using_groovy_to_play_with.html
- [[[3]]] Strater, Jennifer, Cédric Champeau, and Jochen Theodorou. "Potential Bytecode Optimization." Groovy Users
Mailing List. Apache Groovy, 06 Apr. 2017. Web. 16 May 2017. http://mail-archives.apache.org/mod_mbox/groovy-users/201704.mbox/browser
